{"ast":null,"code":"import { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function bufferTime(bufferTimeSpan, ...otherArgs) {\n  var _a, _b;\n  const scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\n  const bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  const maxBufferSize = otherArgs[1] || Infinity;\n  return operate((source, subscriber) => {\n    let bufferRecords = [];\n    let restartOnEmit = false;\n    const emit = record => {\n      const {\n        buffer,\n        subs\n      } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer = [];\n        const record = {\n          buffer,\n          subs\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n    startBuffer();\n    const bufferTimeSubscriber = createOperatorSubscriber(subscriber, value => {\n      const recordsCopy = bufferRecords.slice();\n      for (const record of recordsCopy) {\n        const {\n          buffer\n        } = record;\n        buffer.push(value);\n        maxBufferSize <= buffer.length && emit(record);\n      }\n    }, () => {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, () => bufferRecords = null);\n    source.subscribe(bufferTimeSubscriber);\n  });\n}","map":{"version":3,"names":["Subscription","operate","createOperatorSubscriber","arrRemove","asyncScheduler","popScheduler","executeSchedule","bufferTime","bufferTimeSpan","otherArgs","_a","_b","scheduler","bufferCreationInterval","maxBufferSize","Infinity","source","subscriber","bufferRecords","restartOnEmit","emit","record","buffer","subs","unsubscribe","next","startBuffer","add","push","bufferTimeSubscriber","value","recordsCopy","slice","length","shift","complete","undefined","subscribe"],"sources":["C:/Users/Noril/Documents/team3990/node_modules/rxjs/dist/esm/internal/operators/bufferTime.js"],"sourcesContent":["import { Subscription } from '../Subscription';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { asyncScheduler } from '../scheduler/async';\r\nimport { popScheduler } from '../util/args';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\nexport function bufferTime(bufferTimeSpan, ...otherArgs) {\r\n    var _a, _b;\r\n    const scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\r\n    const bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\r\n    const maxBufferSize = otherArgs[1] || Infinity;\r\n    return operate((source, subscriber) => {\r\n        let bufferRecords = [];\r\n        let restartOnEmit = false;\r\n        const emit = (record) => {\r\n            const { buffer, subs } = record;\r\n            subs.unsubscribe();\r\n            arrRemove(bufferRecords, record);\r\n            subscriber.next(buffer);\r\n            restartOnEmit && startBuffer();\r\n        };\r\n        const startBuffer = () => {\r\n            if (bufferRecords) {\r\n                const subs = new Subscription();\r\n                subscriber.add(subs);\r\n                const buffer = [];\r\n                const record = {\r\n                    buffer,\r\n                    subs,\r\n                };\r\n                bufferRecords.push(record);\r\n                executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\r\n            }\r\n        };\r\n        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\r\n            executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\r\n        }\r\n        else {\r\n            restartOnEmit = true;\r\n        }\r\n        startBuffer();\r\n        const bufferTimeSubscriber = createOperatorSubscriber(subscriber, (value) => {\r\n            const recordsCopy = bufferRecords.slice();\r\n            for (const record of recordsCopy) {\r\n                const { buffer } = record;\r\n                buffer.push(value);\r\n                maxBufferSize <= buffer.length && emit(record);\r\n            }\r\n        }, () => {\r\n            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\r\n                subscriber.next(bufferRecords.shift().buffer);\r\n            }\r\n            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\r\n            subscriber.complete();\r\n            subscriber.unsubscribe();\r\n        }, undefined, () => (bufferRecords = null));\r\n        source.subscribe(bufferTimeSubscriber);\r\n    });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}